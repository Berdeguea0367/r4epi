[
["index.html", "R for Epidemiology Welcome", " R for Epidemiology Brad Cannell 2020-05-25 Welcome Welcome to R for Epidemiology! This electronic book was originally created to accompany my Introduction to R Programming for Epidemiologic Research course at the University of Texas Health Science Center School of Public Health. However, I hope it will be useful to anyone who is interested in R and epidemiology. This book was created by Brad Cannell and is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License. Other Reading You may also be interested in: Hands-on Programming with R by Garrett Grolemund. This book is designed to provide a friendly introduction to the R language. R for Data Science by Garrett Grolemund and Hadley Wickham. This book is designed to teach readers how to do data science with R. Statistical Inference via Data Science: A ModernDive inot R and the Tidyverse. This book is designed to be a gentle introduction to the practice of analyzing data and answering questions using data the way data scientists, statisticians, data journalists, and other researchers would. Reproducable Research with R and RStudio by Christopher Gandrud. This book gives you tools for data gathering, analysis, and presentation of results so that you can create dynamic and highly reproducible research. Advanced R by Hadley Wickham. This book is designed primarily for R users who want to improve their programming skills and understanding of the language. "],
["about-the-author.html", "About the Author", " About the Author Brad Cannell, PhD, MPH Associate Professor Department of Epidemiology, Human Genetics and Environmental Sciences University of Texas Health Science Center School of Public Health Dr. Cannell received his PhD in Epidemiology, and Graduate Certificate in Gerontology, in 2013 from the University of Florida. He received his MPH with a concentration in Epidemiology from the University of Louisville in 2009, and his BA in Political Science and Marketing from the University of North Texas in 2005. During his doctoral studies, he was a Graduate Research Assistant for the Florida Office on Disability and Health, an affiliated scholar with the Claude D. Pepper Older Americans Independence Center, and a student-inducted member of the Delta Omega Honorary Society in Public Health. In 2016, Dr. Cannell received a Graduate Certificate in Predictive Analytics from the University of Maryland University College, and a Certificate in Big Data and Social Analytics from the Massachusetts Institute of Technology. He previously held professional staff positions in the Louisville Metro Health Department and the Northern Kentucky Independent District Health Department. He spent three years as a project epidemiologist for the Florida Office on Disability and Health at the University of Florida. He also served as an Environmental Science Officer in the United States Army Reserves from 2009 to 2013. Dr. Cannell‚Äôs research is broadly focused on healthy aging and health-related quality of life. Specifically, he has published research focusing on preservation of physical and cognitive function, living and aging with disability, and understanding and preventing elder mistreatment. Additionally, he has a strong background and training in epidemiologic methods and predictive analytics. He has been principal or co-investigator on multiple trials and observational studies in community and healthcare settings. He is currently the principal investigator on multiple data-driven federally funded projects that utilize technological solutions to public health issues in novel ways. Contact Email Brad Cannell Brad Cannell‚Äôs LinkedIn Profile Brad Cannell‚Äôs Github page "],
["introduction.html", "Introduction", " Introduction Goals I‚Äôm going to start the introduction by writing down some basic goals that underlie the construction and content of this book. I‚Äôm writing this for you, the reader, but also to hold myself accountable as I write. So, feel free to read if you are interested or skip ahead if you aren‚Äôt. The goals of this book are: To teach you how to use R and RStudio as tools for applied epidemiology. It is not to turn you into a computer scientist or a hard-core R programmer. Therefore, some readers who are experienced programmers may catch some technical inaccuracies on what I consider to be the fine points of what R is doing ‚Äúunder the hood.‚Äù To make this writing as accessible and practically useful as possible without stripping out all of the complexity that makes doing epidemiology in real life a challenge. In other words, I‚Äôm going to try to give you all the tools you need to do epidemiology in ‚Äúreal world‚Äù (as opposed to ideal) conditions without providing a whole bunch of extraneous (often theoretical) stuff that detracts from doing. Having said that, I will strive to add links to the other (often theoretical) stuff for readers who are interested. To teach you to accomplish common tasks, rather than teach you to use functions. In many R courses and texts, I‚Äôve noticed a focus on learning all the things a function, or set of related functions, can do. It‚Äôs then up to you, the reader, to sift through all of these capabilities and decided which, if any, of the things that can be done will accomplish the tasks that you are actually trying to accomplish. Instead, I will strive to start with the end in mind. What is the task we are actually trying to accomplish? What are some functions/methods I could use to accomplish that task? What are the strengths and limitations of each? To start each concept with the end result and then deconstruct how we arrived at that result, where possible. I find that it is easier for me to understand new concepts when learning them as a component of a final product. To learn concepts with data instead of (or alongside) mathematical formulas and text descriptions, where possible. I find that it is easier for me to understand new concepts by seeing them in action. Text conventions used in this book Bold text is used to highlight important terms, URLs, email addresses, file names, and file extensions. Highlighted inline code is used to emphasize small sections of R code, program elements such as variable or function names, databases, data types, environment variables, statements, and keywords. "],
["installing-r-and-rstudio.html", "1 Installing R and RStudio 1.1 Download and install on a Mac 1.2 Download and install on a PC", " 1 Installing R and RStudio Before we can do any programming with R, we first have to download it to your computer. Fortunately, R is free, easy to install, and runs on all major operating systems (i.e., Mac and Windows). However, R by itself is not nearly as easy to use as when we combine it with another program called RStudio. Fortunately, RStudio is also free and will also run on all major operating systems. At this point, you may be wondering what R is, what RStudio is, and how they are related. We will answer those questions in the near future. However, in the interest of keeping things brief and simple, I‚Äôm not going to get into them right now. Instead, all you have to worry about is getting the R programming language and the RStudio IDE (IDE is short for interactive development environment) downloaded and installed on your computer. The steps involved are slightly different depending on whether you are using a Mac or a PC (i.e., Windows). Therefore, please feel free to use the navigation panel on the left-hand side of the screen to navigate directly to the instructions that you need for your computer. üóíSide note: In this chapter, I cover how to download and install R and RStudio on both Mac and PC. However, I personally use a Mac; therefore, the screenshots in all following chapters will be from a Mac. The good news is that RStudio operates almost identically on Mac and PC. Step 1: Regardless of which operating system you are using, please make sure your computer is on, properly functioning, connected to the internet, and has enough space on your hard drive to save R and RStudio. 1.1 Download and install on a Mac Step 2: Navigate to the Comprehensive R Archive Network (CRAN), which is located at https://cran.r-project.org/. Step 3: Click on Download R for (Mac) OS X. Step 4: Click on the link for the latest version of R. As you are reading this, the newest version may be different than the version you see in this picture, but the location of the newest version should be roughly in the same place ‚Äì the middle of the screen under ‚ÄúLatest release:‚Äù. After clicking the link, R should start to download to your computer automatically. Step 5: Locate the package file you just downloaded and double click it. Unless you‚Äôve changed your download settings, this file will probably be in your ‚Äúdownloads‚Äù folder. That is the default location for most web browsers. After you locate the file, just double click it. Step 6: A dialogue box will open and ask you to make some decisions about how and where you want to install R on your computer. I typically just click ‚Äúcontinue‚Äù at every step without changing any of the default options. If R installed properly, you should now see it in your applications folder. Step 7: Now we need to install the RStudio IDE. To do this, navigate to the RStudio desktop download website, which is located at https://rstudio.com/products/rstudio/download/. On that page, click the download button under RStudio Desktop Open Source License Free. Step 8: Download the most current version for Mac. Step 9: Again, locate the dmg file you just downloaded and double click it. Unless you‚Äôve changed your download settings, this file should be in the same location as the R package file you already downloaded. Step 10: A new finder window should automatically pop up that looks like the one you see here. Click on the RStudio icon and drag it into the Applications folder. You should now see RStudio in your Applications folder. Double click the icon to open RStudio. If this warning pops up, just click Open. The RStudio IDE should open and look something like the window you see here. If so, you are good to go! üéâ 1.2 Download and install on a PC Step 2: Navigate to the Comprehensive R Archive Network (CRAN), which is located at https://cran.r-project.org/. Step 3: Click on Download R for Windows. Step 4: Click on the base link. Step 5: Click on the link for the latest version of R. As you are reading this, the newest version may be different than the version you see in this picture, but the location of the newest version should be roughly the same. After clicking, R should start to download to your computer. Step 6: Locate the installation file you just downloaded and double click it. Unless you‚Äôve changed your download settings, this file will probably be in your downloads folder. That is the default location for most web browsers. Step 7: A dialogue box will open that asks you to make some decisions about how and where you want to install R on your computer. I typically just click ‚ÄúNext‚Äù at every step without changing any of the default options. If R installed properly, you should now see it in the Windows start menu. Step 8: Now we need to install the RStudio IDE. To do this, navigate to the RStudio desktop download website, which is located at https://rstudio.com/products/rstudio/download/. On that page, click the download button under RStudio Desktop Open Source License Free. Step 9: Download the most current version for Windows. Step 10: Again, locate the installation file you just downloaded and double click it. Unless you‚Äôve changed your download settings, this file should be in the same location as the R installation file you already downloaded. Step 11: Another dialogue box will open and ask you to make some decisions about how and where you want to install RStudio on your computer. I typically just click ‚ÄúNext‚Äù at every step without changing any of the default options. When RStudio is finished installing, you should see RStudio in the Windows start menu. Click the icon to open RStudio. The RStudio IDE should open and look something like the window you see here. If so, you are good to go! üéâ "],
["what-is-r.html", "2 What is R? 2.1 What is data? 2.2 What is R?", " 2 What is R? At this point in the book, you should have installed R and RStudio on your computer, but you may be thinking to yourself, ‚ÄúI don‚Äôt even know what R is.‚Äù Well, in this chapter you‚Äôll find out. I‚Äôll start with an overview of the R language, and then briefly touch on its capabilities and uses. You‚Äôll also see a complete R program and some complete documents generated by R programs. In this book you‚Äôll learn how to create similar programs and documents, and by the end of the book you‚Äôll be able to write your own R programs and present your results in the form of an issue brief written for general audiences who may or may not have public health expertise. But, before we discuss R let‚Äôs discuss something even more basic ‚Äì data. Here‚Äôs a question for you: What is data? 2.1 What is data? Data is information about objects (e.g., people, places, schools) and observable phenomenon (e.g., weather, temperatures, and disease symptoms) that is recorded and stored somehow as a collection of symbols, numbers, and letters. So, data is just information that has be ‚Äúwritten‚Äù down. Here we have a table, which is a common way of organizing data. In R, we will typically refer to these tables as data frames. Each box is a data frame is called a cell. Moving from left to right across the data frame are columns. Columns are also sometimes referred to as variables. In this book, we will often use the terms columns and variables interchangeably. Each column in a data frame has one, and only one, type. For now, know that the type tells us what kind of data is contained in a column and what we can do with that data. You may have already noticed that 3 of the columns in the table we‚Äôve been looking at contain numbers and 1 of the columns contains words. These columns will have different types in R and we can do different things with them based on their type. For example, we could ask R to tell us what the average value of the numbers in the height column are, but it wouldn‚Äôt make sense to ask R to tell us the average value of the words in the Gender column. We will talk more about many of the different column types exist in R later in this book. The information contained in the first cell of each column is called the column name (or variable) name. R gives us a lot of flexibility in terms of what we can name our columns, but there are a few rules. Column names can contain letters, numbers and the dot (.) or underscore (_) characters. Additionally, they can begin with a letter or a dot ‚Äì as long as the dot is not followed by a number. So, a name like ‚Äú.2cats‚Äù is not allowed. Finally, R has some reserved words that you are not allowed to use for column names. These include: ‚Äúif‚Äù, ‚Äúelse‚Äù, ‚Äúrepeat‚Äù, ‚Äúwhile‚Äù, ‚Äúfunction‚Äù, ‚Äúfor‚Äù, ‚Äúin‚Äù, ‚Äúnext‚Äù, and ‚Äúbreak‚Äù. Moving from top to bottom across the table are rows, which are sometimes referred to as records. Finally, the contents of each cell are called values. You should now be up to speed on some basic terminology used by R, as well as other analytic, database, and spreadsheet programs. These terms will be used repeatedly throughout the course. 2.2 What is R? So, what is R? Well, R is an open source statistical programming language that was created in the 1990‚Äôs specifically for data analysis. We will talk more about what open source means later, but for now, just think of R as an easy (relatively üòÇ) way to ask your computer to do math and statistics for you. More specifically, by the end of this book you will be able to independently use R to access data, manage data, analyze data, and present the results of your analysis. Let‚Äôs quickly take a closer look at each of these. 2.2.1 Accessing data So, what do we mean by ‚Äúaccess data‚Äù? Well, individuals and organizations store their data using different computer programs that use different file types. Some common examples that you may come across in epidemiology are database files, spreadsheets, raw data files, and SAS data sets. No matter how the data is stored, you can‚Äôt do anything with it until you can get it into R, in a form that R can use, and in a location that you can reach. In other words, accessing your data. Therefore, among our first tasks in this course will be to access data. 2.2.2 Managing data This isn‚Äôt very specific, but managing data is all the things you may have to do to your data to get it ready for analysis. You may also hear people refer to this process as data wrangling or data munging. Some specific examples of data management tasks include: Validating and cleaning data. In other words, dealing with potential errors in the data. Subsetting data. For example, using only some of the columns or some of the rows. Creating new variables. For example, creating a BMI variable in a data frame that was sent to you with height and weight columns. Combining data frames. For example, combining sociodemographic data about study participants with data collected in the field during an intervention. You may sometimes hear people refer to the 80/20 rule in reference to data management. This ‚Äúrule‚Äù says that in a typical data analysis project, roughly 80% of your time will be spent on data management and only 20% will be spent on the analysis itself. I can‚Äôt provide you with any empirical evidence (i.e., data) to back this claim up. But, as a person who has been involved in many projects that involve the collection and analysis of data, I can tell you anecdotally that this ‚Äùrule‚Äù is probably pretty close to being accurate in most cases. Additionally, it‚Äôs been my experience that most students of epidemiology are required to take one or more classes that emphasize methods for analyzing data; however, almost none of them have taken a course that emphasizes data management! Therefore, because data management is such a large component of most projects that involve the collection and analysis of data, and because most readers will have already been exposed to data analysis to a much greater extent than data management, this course will heavily emphasize the latter. 2.2.3 Analyzing data As just discussed, this is probably the capability you most closely associate with R, and there is no doubt that R is a powerful tool for analyzing data. However, in this book we won‚Äôt go beyond using R to calculate basic descriptive statistics. For our purposes, descriptive statistics include: Measures of central tendency. For example, mean, median, and mode. Measures of dispersion. For example, variance and standard error. Measures for describing categorical variables. For example, counts and percentages. Describing data using graphs and charts. With R, we can describe our data using beautiful and informative graphs. 2.2.4 Presenting data And finally, the ultimate goal is typically to present your findings in some form or another. For example, a report, a website, or a journal article. With R you can present your results in many different formats with relative ease. In fact, this is one of my favorite things about R and RStudio. In this class you will learn how to take your text, tabular, or graphical results and then publish them in many different formats including Microsoft Word, html files that can be viewed in web browsers, and pdf documents. Let‚Äôs take a look at some examples. Microsoft Word documents. Click here to view an example report created for one of my research projects in Microsoft Word. PDF documents. Click here to view a data dictionary I created in PDF format. HTML files. Hypertext Markup Language (HTML) files are what you are looking at whenever you view a webpage. You can use are to create HTML files that others can view in their web browser. You can email them these files to view in their web browser, or you can make them available for others to view online just like any other website. Click here to view an example dashboard I created for one of my research projects. Web applications. You can even use R to create full-fledged web applications. View the RStudio website to see some examples. "],
["navigating-the-rstudio-interface.html", "3 Navigating the RStudio interface 3.1 The console 3.2 The environment pane 3.3 The files pane 3.4 The source pane 3.5 RStudio preferences", " 3 Navigating the RStudio interface You now have R and RStudio on your computer and you have some idea of what R and RStudio are. At this point, it is really common for people to open RStudio and get totally overwhelmed. ‚ÄúWhat am I looking at?‚Äù ‚ÄùWhat do I click first?‚Äù ‚ÄúWhere do I even start?‚Äù Don‚Äôt worry if these, or similar, thoughts have crossed your mind. You are in good company and we will start to clear some of them up in this chapter. When you first load RStudio you should see a screen that looks very similar to what you see in the picture below. 3.1 In the current view, you see three panes and each pane has multiple tabs. Don‚Äôt beat yourself up if this isn‚Äôt immediately obvious. I‚Äôll make it clearer soon. Figure 3.1: The default RStudio user interface. 3.1 The console The first pane we are going to talk about is the Console/Terminal/Jobs pane. 3.2 Figure 3.2: The R console. It‚Äôs called the Console/Terminal/Jobs pane because it has three tabs you can click on: Console, Terminal, and Jobs. However, we will mostly refer to it as the Console pane and we will mostly ignore the Terminal and Jobs tabs. We aren‚Äôt ignoring them because they aren‚Äôt useful; rather, we are ignoring them because using them isn‚Äôt essential for anything we discuss anytime soon, and I want to keep things as simple as possible. The console is the most basic way to interact with R. You can type a command to R into the console prompt (the prompt looks like ‚Äú&gt;‚Äù) and R will respond to what you type. For example, below I‚Äôve typed ‚Äú1 plus 1,‚Äù hit enter, and the R console returned the sum of the numbers 1 and 1. 3.3 Figure 3.3: Doing some addition in the R console. The number 1 you see in brackets before the 2 (i.e., [1]) is telling you that this line of results starts with the first result. That fact is obvious here because there is only one result. To make this idea clearer, let‚Äôs show you a result with multiple lines. Figure 3.4: Demonstrating a function that returns multiple results. In the screenshot above we see a couple new things demonstrated. 3.4 First, as promised, we have more than one line of results (or output). The first line of results starts with a 1 in brackets (i.e., [1]), which indicates that this line of results starts with the first result. In this case the first result is the number 2. The second line of results starts with a 29 in brackets (i.e., [29]), which indicates that this line of results starts with the twenty-ninth result. In this case the twenty-ninth result is the number 58. If you count the numbers in the first line, there should be 28 ‚Äì results 1 through 28. I also want to make it clear that ‚Äú1‚Äù and ‚Äú29‚Äù are NOT results themselves. They are just helping us count the number of results per line. The second new thing here that you may have noticed is our use of a function. Functions are a BIG DEAL in R. So much so that R is called a functional language. You don‚Äôt really need to know all the details of what that means; however, you should know that, in general, everything you do in R you will do with a function. By contrast, everything you create in R will be an object. If you wanted to make an analogy between the R language and the English language, functions are verbs ‚Äì they do things ‚Äì and objects are nouns ‚Äì they are things. This may be confusion right now. Don‚Äôt worry. It will become clearer soon. Most functions in R begin with the function name followed by parentheses. For example, seq(), sum(), and mean(). Question: What is the name of the function we used in the example above? It‚Äôs the seq() function ‚Äì short for sequence. Inside the function, you may notice that there are three pairs of words, equal symbols, and numbers that are separated by commas. They are, from = 2, to = 100, and by = 2. In this case, from, to, and by are all arguments to the seq() function. I don‚Äôt know why they are called arguments, but as far as we are concerned, they just are. We will learn more about functions and arguments later, but for now just know that arguments give functions the information they need to give us the result we want. In this case, the seq() function gives us a sequence of numbers, but we have to give it information about where that sequence should start, where it should end, and how many steps should be in the middle. Here the sequence begins with the value we gave to the from argument (i.e., 2), ends with the value we gave to the to argument (i.e., 100), and increases at each step by the number we gave to the by argument (i.e., 2). So, 2, 4, 6, 8 ‚Ä¶ 100. While it‚Äôs convenient, let‚Äôs also learn some programming terminology: Arguments: Arguments always go inside the parentheses of a function and give the function the information it needs to give us the result we want. Pass: In programming lingo, you pass a value to a function argument. For example, in the function call seq(from = 2, to = 100, by = 2) we could say that we passed a value of 2 to the from argument, we passed a value of 100 to the to argument, and we passed a value of 2 to the by argument. Returns: Instead of saying, ‚Äúthe seq() function gives us a sequence of numbers‚Ä¶‚Äù we could say, ‚Äúthe seq() function returns a sequence of numbers‚Ä¶‚Äù In programming lingo, functions return one or more results. üóí Side note: The seq() function isn‚Äôt particularly important or noteworthy. I essentially chose it at random to illustrate some key points. However, arguments, passing values, and return values are extremely important concepts and we will return to them many times. 3.2 The environment pane The second pane we are going to talk about is the Environment/History/Connections pane. 3.5 However, we will mostly refer to it as the Environment pane and we will mostly ignore the History and Connections tab. We aren‚Äôt ignoring them because they aren‚Äôt useful; rather, we are ignoring them because using them isn‚Äôt essential for anything we will discuss anytime soon, and I want to keep things as simple as possible. Figure 3.5: The environment pane. The Environment pane shows you all the objects that R can currently use for data management or analysis. In this picture, 3.5 our environment is empty. Let‚Äôs create an object and add it to our Environment. Figure 3.6: The vector x in the global environment. Here we see that we created a new object called x, which now appears in our Global Environment. 3.6 This gives us another great opportunity to discuss some new concepts. First, we created the x object in the Console by assigning the value 2 to the letter x. We did this by typing ‚Äúx‚Äù followed by a less than symbol (&lt;), a dash symbol (-), and the number 2. R is kind of unique in this way. I have never seen another programming language (although I‚Äôm sure they are out there) that uses &lt;- to assign values to variables. By the way, &lt;- is called the assignment operator (or assignment arrow), and ‚Äùassign‚Äù here means ‚Äúmake x contain 2‚Äù or ‚Äúput 2 inside x.‚Äù In many other languages you would write that as x = 2. But, for whatever reason, in R it is &lt;-. Unfortunately, &lt;- is more awkward to type than =. Fortunately, RStudio gives us a keyboard shortcut to make it easier. To type the assignment operator in RStudio, just hold down Option + - (dash keey) on a Mac or Alt + - (dash key) on a PC and RStudio will insert &lt;- complete with spaces on either side of the arrow. This may still seem awkward at first, but you will get used to it. üóí A side note about using the letter ‚Äúx‚Äù: By convention, the letter ‚Äúx‚Äù is a widely used variable name. You will see it used a lot in example documents and online. However, there is nothing special about the letter x. We could have just as easily used any other letter (a &lt;- 2), word (variable &lt;- 2), or descriptive name (my_favorite_number &lt;- 2) that is allowed by R. Second, you can see that our Global Environment now includes the object x, which has a value of 2. In this case, we would say that x is a numeric vector of length 1 (i.e., it has one value stored in it). We will talk more about vectors and vector types soon. For now, just notice that objects that you can manipulate or analyze in R will appear in your Global Environment. üóí‚ÄºÔ∏è Side note: R is a case sensitive language. That means that upper case x (X) and lower case x (x) are different things to R. So, if you assign 2 to lower case x (x &lt;- 2). And then later ask R to tell what number you stored in upper case X, you will get an error (Error: object 'X' not found). 3.3 The files pane Next, let‚Äôs talk about the Files/Plots/Packages/Help/Viewer pane (that‚Äôs a mouthful). 3.7 Figure 3.7: The Files/Plots/Packages/Help/Viewer pane. Again, some of these tabs are more applicable for us than others. For us, the files tab and the help tab will probably be the most useful. You can think of the files tab as a mini Finder window (for Mac) or a mini File Explorer window (for PC). The help tab is also extremely useful once you get acclimated to it. Figure 3.8: The help tab. For example, in the screenshot above 3.8 we typed the seq into the search bar. The help pane then shows us a page of documentation for the seq() function. The documentation includes a brief description of what the function does, outlines all the arguments the seq() function recognizes, and, if you scroll down, gives examples of using the seq() function. Admittedly, this help documentation can seem a little like reading Greek (assuming you don‚Äôt speak Greek) at first. But, you will get more comfortable using it with practice. I hated the help documentation when I was learning R. Now, I use it all the time. 3.4 The source pane There is actually a fourth pane available in RStudio. If you click on the icon shown below you will get the following dropdown box with a list of files you can create. 3.9 Figure 3.9: Click the new source file icon. If you click any of these options, a new pane will appear. I will arbitrarily pick the first option ‚Äì R Script. Figure 3.10: New source file options. When I do, a new pane appears. It‚Äôs called the source pane. In this case, the source pane contains an untitled R Script. We won‚Äôt get into the details now because I don‚Äôt want to overwhelm you, but soon you will do the majority of your R programming in the source pane. Figure 3.11: A blank R script in the source pane. 3.5 RStudio preferences Finally, I‚Äôm going to recommend that you change a few settings in RStudio before we move on. Start by going to RStudio -&gt; Preferences (on Mac) 3.12 Figure 3.12: Select the preferences menu on Mac. Or start by going to Tools -&gt; Global Options (on Windows) 3.13 Figure 3.13: Select the global options menu on Windows. In the ‚ÄúGeneral‚Äù tab, I recommend unchecking the ‚ÄúRestore .Rdata into workspace at startup‚Äù checkbox. I also recommend setting the ‚ÄúSave workspace .Rdata on exit‚Äù dropdown to ‚ÄúNever.‚Äù Finally, I recommend unchecking the ‚ÄúAlways save history (even when not saving .Rdata)‚Äù checkbox. 3.14 Figure 3.14: General options tab. On the ‚ÄúAppearance‚Äù tab, I‚Äôm going to change my Editor Theme to Twilight. It‚Äôs not so much that I‚Äôm recommending you change yours ‚Äì this is entirely personal preference ‚Äì I‚Äôm just letting you know why my screenshots will look different from here on out. 3.15 Figure 3.15: Appearance tab. I‚Äôm sure you still have lots of questions at this point. That‚Äôs totally natural. However, I hope you now feel like you have some idea of what you are looking at when you open RStudio. Most of you will naturally get more comfortable with RStudio as we move through the book. For those of you who want more resources now, here are some suggestions. RStudio IDE cheatsheet ModernDive: What are R and RStudio? "],
["speaking-rs-language.html", "4 Speaking R‚Äôs language 4.1 R is a language 4.2 The R interpreter 4.3 Errors 4.4 Functions 4.5 Objects 4.6 Comments 4.7 Packages 4.8 Programming style", " 4 Speaking R‚Äôs language Students taking my R for epidemiology course often come into the course thinking it will be a math or statistics course. In reality, this course is probably much closer to a foreign language course. There is no doubt that we need a foundational understanding of math and statistics to understand the results we get from R, but R will take care of all of the complicated stuff for us. All we have to do is learn how to ask R to do what we want it to do. To some extent, this entire book is about learning to communicate with R. So, in this chapter we will introduce the R programming language from the 30,000-foot level. 4.1 R is a language In the same way that many people use the English language to communicate with each other, we will use the R programming language to communicate with R. Just like the English language, the R language comes complete with its own structure and vocabulary. Unfortunately, just like the English language, it also includes some weird exceptions and occasional miscommunications. We‚Äôve already seen a couple examples of commands written to R in the R programming language. Specifically: # Store the value 2 in the variable x x &lt;- 2 # Print the contents of x to the screen x ## [1] 2 and # Print an example number sequence to the screen seq(from = 2, to = 100, by = 2) ## [1] 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 ## [20] 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 ## [39] 78 80 82 84 86 88 90 92 94 96 98 100 üóí Side note: The gray the boxes you see above are called R code chunks and I created them (and this entire book) using something called R markdown documents. Can you believe that you can write an entire book with R and RStudio? How cool is that? You will learn to use R markdown documents later in the workflow basics portion of this book. R markdown is great because it allows you to mix R code with narrative text and multimedia content as I‚Äôve done throughout the page you‚Äôre currently looking at. This makes it really easy for us to add context and aesthetic appeal to our results. 4.2 The R interpreter Question: I keep talking about ‚Äúspeaking‚Äù to R, but when you speak to R using the R language, who are you actually speaking to? Well, you are speaking to something called the R interpreter. The R interpreter takes the commands we‚Äôve written in the R language, sends them to your computer to do the actual work (e.g., get the mean of a set of numbers), and then translates the results of that work back to us in a form that we humans can understand (e.g., the mean is 25.5). At this stage, one of the key concepts for you to understand about the R language is that is extremely literal! Understanding the literal nature of R is important because it will be the underlying cause of a lot of errors in your R code. 4.3 Errors No matter what I write next, you are going to get errors in your R code. I still get errors in my R code every single time I write R code. However, my hope is that this section will help you begin to understand why you are getting errors when you get them and provide us with a common language for discussing errors. So, what exactly do I mean when I say that the R interpreter is extremely literal? Well, in the Navigating RStudio chapter I already told you that R is a case sensitive language. Again, that means that upper case x (X) and lower-case x (x) are different things to R. So, if you assign 2 to lower case x (x &lt;- 2). And then later ask R to tell what number you stored in upper case X; you will get an error (Error: object 'X' not found). x &lt;- 2 X ## Error in eval(expr, envir, enclos): object &#39;X&#39; not found Specifically, this is an example of a logic error. Meaning, R understands what you are asking it to do ‚Äì you want it to print the contents of the upper-case X object to the screen. However, it can‚Äôt complete your request because you are asking it to do something that doesn‚Äôt logically make sense ‚Äì print the contents of a thing that doesn‚Äôt exist. Remember, R is literal, and it will not try to guess that you actually meant to ask it to print the contents of lower-case x. Another general type of error is known as a syntax error. In programming languages, syntax refers to the rules of the language. You can sort of think of this as the grammar of the language. In English, I could say something like, ‚Äúgiving dog water drink.‚Äù This sentence is grammatically completely incorrect; however, most of you would roughly be able to figure out what I‚Äôm asking you to do based on your life experience and knowledge of the situational context. The R interpreter, as awesome as it is, would not be able to make an assumption about what I want it to do. There would either be one, and only one, preprogrammed correct response to such a request, or the R interpreter would say, ‚ÄúI don‚Äôt know what you‚Äôre asking me to do.‚Äù When the R interpreter says, ‚ÄúI don‚Äôt know what you‚Äôre asking me to do,‚Äù you‚Äôve made a syntax error. Throughout the rest of the book, I will try to point out situations where R programmers often encounter errors and how you may be able to address them. The remainder of this chapter will discuss some key components of R‚Äôs syntax and the data structures (i.e., ways of storing data) that the R syntax interacts with. 4.4 Functions R is a functional programming language, which simply means that functions play a central role in the R language. But what are functions? Well, factories are a common analogy used to represent functions. In this analogy, arguments are raw material inputs that go into the factory. For example, steel and rubber. The function is the factory where all the work takes place ‚Äì converting raw materials into the desired output. Finally, the factory output represents the returned results. In this case, bicycles. Figure 4.1: A factory making bicycles. To make this concept more concrete, in the Navigating RStudio chapter we used the seq() function as a factory. Specifically, we wrote seq(from = 2, to = 100, by = 2). The inputs (arguments) were from, to, and by. The output (returned result) was a set of numbers that went from 2 to 100 by 2‚Äôs. Most functions, like the seq() function, will be a word or word part followed by parentheses. Other examples are the sum() function for addition and the mean() function to calculate the average value of a set of numbers. Figure 4.2: A function factory making numbers. 4.5 Objects In addition to functions, the R programming language also includes objects. In the Navigating RStudio chapter we created an object called x with a value of 2 using the x &lt;- 2 R code. In general, you can think of objects as anything that lives in your R global environment. Objects may be single variables (also called vectors in R) or entire data sets (also called data frames in R). Objects can be a confusing concept at first. I think it‚Äôs because it‚Äôs is hard to precisely define exactly what an object is. I‚Äôll say two things about this. First, you‚Äôre probably overthinking it. When we use R, we create and save stuff. We have to call that stuff something in order to talk about it or write books about it. Somebody decided we would call that stuff ‚Äúobjects.‚Äù The second thing I‚Äôll say is that this becomes much less abstract when we finally get to a place where you can really get your hands dirty doing some R programming. Figure 4.3: Creating the x object. Sometimes it can be useful to relate the R language to English grammar. That is, when you are writing R code you can roughly think of functions as verbs and objects as nouns. Just like nouns are things in the English language, and verbs do things in the English language, objects are things and functions do things in the R language. So, in the x &lt;- 2 command x is the object and &lt;- is the function. ‚ÄúWait! Didn‚Äôt you just tell us that functions will be a word followed by parentheses?‚Äù Fair question. Technically, I said, ‚ÄúMost functions will be a word, or word part, followed by parentheses.‚Äù Just like English, R has exceptions. All operators in R are also functions. Operators are symbols like +, -, =, and &lt;-. There are many more operators, but you will notice that they all do things. In this case, they add, subtract, and assign values to objects. 4.6 Comments And finally, there are comments. If our R code is a conversation we are having with the R interpreter, then comments are your inner thoughts taking place during the conversation. Comments don‚Äôt actually mean anything to R, but they will be extremely important for you. You actually already saw a couple examples of comments above. # Store the value 2 in the variable x x &lt;- 2 # Print the contents of x to the screen x ## [1] 2 In this code chunk, ‚Äú# Store the value 2 in the variable x‚Äù and ‚Äú# Print the contents of x to the screen‚Äù are both examples of comments. Notice that they both start with the pound or hash sign (#). The R interpreter will ignore anything on the current line that comes after the hash sign. A carriage return (new line) ends the comment. However, comments don‚Äôt have to be written on their own line. They can also be written on the same line as R code as long as put them after the R code, like this: x &lt;- 2 # Store the value 2 in the variable x x # Print the contents of x to the screen ## [1] 2 Most beginning R programmers underestimate the importance of comments. In the silly little examples above, the comments are not that useful. However, comments will become extremely important as you begin writing more complex programs. When working on projects, you will often need to share your programs with others. Reading R code without any context is really challenging ‚Äì even for experienced R programmers. Additionally, even if your collaborators can surmise what your R code is doing, they may have no idea why you are doing it. Therefore, your comments should tell others what your code does (if it isn‚Äôt completely obvious), and more importantly, what your code is trying to accomplish. Even if you aren‚Äôt sharing your code with others, you may need to come back and revise or reuse your code months or years down the line. You may be shocked at how foreign the code you wrote will seem months or years after you wrote it. Therefore, comments are just important for others, they are important for future you! 4.7 Packages In addition to being a functional programming language, R is also a type of programming language called an open source programming language. For our purposes, this has two big advantages. First, it means that R is FREE! Second, it means that smart people all around the world get to develop new packages for the R language that can do cutting edge and/or very niche things. That second advantage is probably really confusing if this is not a concept you are already familiar with. For example, when you install Microsoft Word on your computer all the code that makes that program work is owned and Maintained by the Microsoft corporation. If you need Word to do something that it doesn‚Äôt currently do, your only option is really to make a feature request on Microsoft‚Äôs website. R works a little differently. When you downloaded R from the CRAN website, you actually download something called Base R. Base R maintained by the R Core Team. However, anybody ‚Äì even you ‚Äì can write your own code (called packages) that add new functions to the R syntax. Like all functions, these new functions allow you to do things that you can‚Äôt do (or can‚Äôt do as easily) with Base R. An analogy that I really like here is used by Ismay and Kim in ModernDive. A good analogy for R packages is they are like apps you can download onto a mobile phone. So R is like a new mobile phone: while it has a certain amount of features when you use it for the first time, it doesn‚Äôt have everything. R packages are like the apps you can download onto your phone from Apple‚Äôs App Store or Android‚Äôs Google Play. 1 So, when you get a new smart phone it comes with apps for making phone calls, checking email, and sending text messages. But, what if you want to listen to music on Spotify? You may or may not be able to do that through your phone‚Äôs web browser, but it‚Äôs way more convenient and powerful to download and install the Spotify app. In this course, we will make extensive use of packages developed by people and teams outside of the R Core Team. In particular, we will use a number of related packages that are collectively known as the Tidyverse. One of the most popular packages in the tidyverse collection (and one of the most popular R packages overall) is called the dplyr package for data management. In the same way that you have to download and install Spotify on your mobile phone before you can use it, you have to download and install new R packages on your computer before you can use the functions they contain. Fortunately, R makes this really easy. For most packages, all you have to do is run the install.packages() function in the R console. For example, here is how you would install the dplyr package. # Make sure you remember to wrap the name of the package in single or double quotes. install.packages(&quot;dplyr&quot;) Over time, you will download and install a lot of different packages. All those packages with all of those new functions start to create a lot of overhead. Therefore, R doesn‚Äôt keep them loaded and available for use at all times. Instead, every time you open RStudio, you will have to explicitly tell R which packages you want to use. So, when you close RStudio and open it again, the only functions that you will be able to use are Base R functions. If you want to use functions from any other package (e.g., dplyr) you will have to tell R that you want to do so using the library() function. # No quotes needed here library(dplyr) Technically, loading the package with the library() function is not the only way to use a function from a package you‚Äôve downloaded. For example, the dplyr package contains a function called filter() that helps us keep or drop certain rows in a data frame. To use this function, we have to first download the dplyr package. Then we can use the filter function in one of two different ways. library(dplyr) filter(states_data, state == &quot;Texas&quot;) # Keeps only the rows from Texas The first way you already saw above. Load all the functions contained in the dplyr package using the library() function. Then use that function just like any other Base R function. The second way is something called the double colon syntax. To use the double colon syntax, you type the package name, two colons, and the name of the function you want to use from the package. Here is an example of the double colon syntax. dplyr::filter(states_data, state == &quot;Texas&quot;) # Keeps only the rows from Texas Most of the time you will load packages using the library() function. However, I wanted to show you the double colon syntax because you may come across it when you are reading R documentation and because there are times when it makes sense to use this syntax. 4.8 Programming style Finally, I want to discuss programming style. R can read any code your write as long as your write it using valid R syntax. However, R code can be much easier or harder for people (including you) to read depending on how it‚Äôs written. The coding best practices chapter of this book gives complete details on writing R code that is as easy as possible for people to read. So, please make sure to read it. It will make things so much easier for all of us! References "],
["lets-get-programming.html", "5 Let‚Äôs get programming 5.1 Simulating data 5.2 Vectors 5.3 Data frames 5.4 Our first analysis 5.5 Some common errors 5.6 Summary", " 5 Let‚Äôs get programming In this chapter, we are going to tie together many of the concepts we‚Äôve learned so far, and you are going to create your first basic R program. Specifically, you are going to write a program that simulates some data and analyzes it. 5.1 Simulating data Data simulation can be really complicated, but it doesn‚Äôt have to be. It is simply the process of creating data as opposed to finding data in the wild. This can be really useful in several different ways. Simulating data is really useful for getting help with a problem you are trying to solve. Often, it isn‚Äôt feasible for you to send other people the actual data set you are working on when you encounter a problem you need help with. Sometimes, it may not even be legally allowed (i.e., for privacy reasons). Instead of sending them your entire data set, you can simulate a little data set that recreates the challenge you are trying to address without all the other complexity of the full data set. As a bonus, I have often found that I end up figuring out the solution to the problem I‚Äôm trying to solve as I recreate the problem in a simulated data set that I intended to share with others. Simulated data can also be useful for learning about and testing statistical assumptions. In epidemiology, we use statistics to draw conclusions about populations of people we are interested in based on samples of people drawn from the population. Because we don‚Äôt actually have data from all the people in the population, we have to make some assumptions about the population based on what we find in our sample. When we simulate data, we know the truth about our population because we created our population to have that truth. We can then use this simulated populations to play ‚Äúwhat if‚Äù games with our analysis. What if we only sampled half as many people? What if their heights aren‚Äôt actually normally distributed? What if we used a probit model instead of a logit model? Going through this process and answering these questions can help us understand how much, and under what circumstances, we can trust the answers we found in the real world. So, let‚Äôs go ahead write a complete R program to simulate and analyze some data. As I said, it doesn‚Äôt have to be complicated. In fact, in just a few lines of R code below we simulate and analyze some data about a hypothetical class. class &lt;- data.frame( names = c(&quot;John&quot;, &quot;Sally&quot;, &quot;Brad&quot;, &quot;Anne&quot;), heights = c(68, 63, 71, 72) ) class ## names heights ## 1 John 68 ## 2 Sally 63 ## 3 Brad 71 ## 4 Anne 72 mean(class$heights) ## [1] 68.5 As you can see, this data frame contains the students‚Äô names and heights. We also use the mean() function to calculate the average height of the class. By the end of this chapter, you will understand all the elements of this R code and how to simulate your own data. 5.2 Vectors Vectors are the most fundamental data structure in R. Here, data structure means ‚Äúcontainer for our data.‚Äù There are other data structures as well; however, they are all built from vectors. That‚Äôs why I say vectors are the most fundamental data structure. Some of these other structures include matrices, lists, and data frames. In this book, we won‚Äôt use matrices or lists much at all, so you can forget about them for now. Instead, we will almost exclusively use data frames to hold and manipulate our data. However, because data frames are built from vectors, it can be useful to start by learning a little bit about them. Let‚Äôs create our first vector now. # Create an example vector names &lt;- c(&quot;John&quot;, &quot;Sally&quot;, &quot;Brad&quot;, &quot;Anne&quot;) # Print contents to the screen names ## [1] &quot;John&quot; &quot;Sally&quot; &quot;Brad&quot; &quot;Anne&quot; üëÜHere‚Äôs what we did above: We created a vector of names with the c() (short for combine) function. The vector contains four values: ‚ÄúJohn‚Äù, ‚ÄúSally‚Äù, ‚ÄúBrad‚Äù, and ‚ÄúAnne‚Äù. All of the values are character strings (i.e., words). We know this because all of the values are wrapped with quotation marks. Here we used double quotes above, but we could have also used single quotes. We cannot, however, mix double and single quotes for each character string. For example, c(\"John', ...) won‚Äôt work. We assigned that vector of character strings to the word names using the &lt;- function. R now recognizes names as an object that we can do things with. R programmers may refer to the names object as ‚Äúthe names object‚Äù, ‚Äúthe names vector‚Äù, or ‚Äúthe names variable‚Äù. For our purposes, these all mean the same thing. We printed the contents of the names object to the screen by typing the word ‚Äúnames‚Äù. R returns (shows us) the four character values (‚ÄúJohn‚Äù ‚ÄúSally‚Äù ‚ÄúBrad‚Äù ‚ÄúAnne‚Äù) on the computer screen. Try copying and pasting the code above into the RStudio console on your computer. You should notice the names vector appear in your global environment. You may also notice that the global environment pane gives you some additional information about this vector to the right of its name. Specifically, you should see chr [1:4] \"John\" \"Sally\" \"Brad\" \"Anne\". This is R telling us that names is a character vector (chr), with four values ([1:4]), and the first four values are \"John\" \"Sally\" \"Brad\" \"Anne\". 5.2.1 Vector types There are several different vector types, but each vector can have only one type. The type of the vector above was character. We can validate that with the typeof() function like so: typeof(names) ## [1] &quot;character&quot; The other vector types that we will use in this book are double, integer, and logical. Double vectors hold real numbers and integer vectors hold integers. Collectively, double vectors and integer vectors are known as numeric vectors. Logical vectors can only hold the values TRUE and FALSE. Here are some examples of each: 5.2.2 Double vectors # A numeric vector my_numbers &lt;- c(12.5, 13.98765, pi) my_numbers ## [1] 12.500000 13.987650 3.141593 typeof(my_numbers) ## [1] &quot;double&quot; # An integer vector - first attempt my_ints_1 &lt;- c(1, 2, 3) my_ints_1 ## [1] 1 2 3 typeof(my_ints_1) ## [1] &quot;double&quot; 5.2.3 Integer vectors # An integer vector # Must put &quot;L&quot; behind the number to make it an integer. No idea why they chose &quot;L&quot;. my_ints_2 &lt;- c(1L, 2L, 3L) my_ints_2 ## [1] 1 2 3 typeof(my_ints_2) ## [1] &quot;integer&quot; 5.2.4 Logical vectors # An integer vector # Type TRUE and FALSE in all caps my_logical &lt;- c(TRUE, FALSE, TRUE) my_logical ## [1] TRUE FALSE TRUE typeof(my_logical) ## [1] &quot;logical&quot; Rather than have an abstract discussion about the particulars of each of these vector types right now, I think it‚Äôs best to wait and learn more about them when they naturally arise in the context of a real challenge we are trying to solve with data. At this point, just having some vague idea that they exist is good enough. 5.3 Data frames Vectors are useful for storing a single type of information. However, in epidemiology we typically want to know many different types of information about whatever we happen to be studying. For example, we didn‚Äôt just want the names of the people in our class, we also wanted the heights. Of course, we can also store the heights in a vector like so: heights &lt;- c(68, 63, 71, 72) heights ## [1] 68 63 71 72 But this vector, in and of itself, doesn‚Äôt tell us which height goes with which person. When we want to create relationships between our vectors, we can use them to build a data frame. For example: # Create a vector of names names &lt;- c(&quot;John&quot;, &quot;Sally&quot;, &quot;Brad&quot;, &quot;Anne&quot;) # Create a vector of heights heights &lt;- c(68, 63, 71, 72) # Combine them into a data frame class &lt;- data.frame(names, heights) # Print the data frame to the screen class ## names heights ## 1 John 68 ## 2 Sally 63 ## 3 Brad 71 ## 4 Anne 72 üëÜHere‚Äôs what we did above: We created a data frame with the data.frame() function. The first argument we passed to the data.frame() function was a vector of names that we previously created. The second argument we passed to the data.frame() function was a vector of heights that we previously created. We assigned that data frame to the word class using the &lt;- function. R now recognizes class as an object that we can do things with. R programmers may refer to the names object as ‚Äúthe class object‚Äù or ‚Äúthe class data frame‚Äù. For our purposes, these all mean the same thing. We could also call it a data set, but that term isn‚Äôt used much in R circles. We printed the contents of the class object to the screen by typing the word ‚Äúclass‚Äù. R returns (shows us) the data frame on the computer screen. Try copying and pasting the code above into the RStudio console on your computer. You should notice the class data frame appear in your global environment. You may also notice that the global environment pane gives you some additional information about this data frame to the right of its name. Specifically, you should see 4 obs. of 2 variables. This is R telling us that class has four rows or observations (4 obs.) and two columns or variables (2 variables). If you click the little blue arrow to the left of the data frame‚Äôs name, you will see information about the individual vectors that make up the data frame. As a shortcut, instead of creating individual vectors and then combining them into a data frame as we‚Äôve done above, most R programmers will create the vectors (columns) directly inside of the data frame function like this: # Create the class data frame class &lt;- data.frame( names = c(&quot;John&quot;, &quot;Sally&quot;, &quot;Brad&quot;, &quot;Anne&quot;), heights = c(68, 63, 71, 72) ) # Closing parenthesis down here. # Print the data frame to the screen class ## names heights ## 1 John 68 ## 2 Sally 63 ## 3 Brad 71 ## 4 Anne 72 As you can see, both methods produce the exact same result. The second method, however, requires a little less typing and results in fewer objects cluttering up your global environment. What I mean by that is that the names and heights vectors won‚Äôt exist independently in your global environment. Rather, they will only exist as columns of the class data frame. You may have also noticed that when we created the names and heights vectors (columns) directly inside of the data.frame() function we used the equal sign (=) to assign values instead of the assignment arrow (&lt;-). This is just one of those quirky R exceptions we talked about in the chapter on speaking R‚Äôs language. In fact, = and &lt;- can be used interchangeably in R. It is only by convention that we usually use &lt;- for assigning values, but use = for assigning values to columns in data frames. I don‚Äôt know why this is the convention. If it were up to me, we wouldn‚Äôt do this. We would just pick = or &lt;- and use it in all cases where we want to assign values. But, it isn‚Äôt up to me and I gave up on trying to fight it a long time ago. Your R programming life will be easier if you just learn to assign values this way ‚Äì even if it‚Äôs dumb. ü§∑ 5.4 Our first analysis Congratulations on your new R programming skills. üéâ You can now create vectors and data frames. This is no small thing. Basically, everything else we do in this book will start with vectors and data frames. Having said that, just creating data frames may not seem super exciting. So, let‚Äôs round out this chapter with a basic descriptive analysis of the data we simulated. Specifically, let‚Äôs find the average height of the class. You will find that in R there are almost always many different ways to accomplish a given task. Sometimes, choosing one over another is simply a matter of preference. Other times, one method is clearly more efficient and/or accurate than another. This is a point that will come up over and over in this book. Let‚Äôs use our desire to find the mean height of the class as an example. 5.4.1 Manual calculation of the mean For starters, we can add up all the heights and divide by the total number of heights to find the mean. (68 + 63 + 71 + 72) / 4 ## [1] 68.5 üëÜHere‚Äôs what we did above: We used the addition operator (+) to add up all the heights. We used the division operator (/) to divide the sum of all the heights by 4 - the number of individual heights we added together. We used parentheses to enforce the correct order of operations (i.e., make R do addition before division). This works, but why might it not be the best approach? Well, for starters, manually typing in the heights is error prone. We can easily accidently press the wrong key. Luckily, we already have the heights stored as a column in the class data frame. We can access or refer to a single column in a data frame using the dollar sign notation. 5.4.2 Dollar sign notation class$heights ## [1] 68 63 71 72 üëÜHere‚Äôs what we did above: We used the dollar sign notation to access the heights column in the class data frame. Dollar sign notation is just the data frame name, followed by the dollar sign, followed by the column name. 5.4.3 Bracket notation Further, we can use bracket notation to access each value in a vector. I think it‚Äôs easier to demonstrate bracket notation than it is to describe it. For example, we could access the third value in the names vector like this: # Create the heights vector heights &lt;- c(68, 63, 71, 72) # Bracket notation # Access the third element in the heights vector with bracket notation heights[3] ## [1] 71 Remember, that data frame columns are also vectors. So, we can combine the dollar sign notation and bracket notation, to access each individual value of the height column in the class data frame. This will help us get around the problem of typing each individual height value. For example: # First way to calculate the mean # (68 + 63 + 71 + 72) / 4 # Second way. Use dollar sign notation and bracket notation so that we don&#39;t have to type individual heights (class$heights[1] + class$heights[2] + class$heights[3] + class$heights[4]) / 4 ## [1] 68.5 5.4.4 The sum function The second method is better in the sense that we no longer have to worry about mistyping the heights. However, who wants to type class$heights[...] over and over? What if we had a hundred numbers? What if we had a thousand numbers? This wouldn‚Äôt work. Luckily, there is a function that adds all the numbers contained in a numeric vector ‚Äì the sum() function. Let‚Äôs take a look: # Create the heights vector heights &lt;- c(68, 63, 71, 72) # Add together all the individual heights with the sum function sum(heights) ## [1] 274 Remember, that data frame columns are also vectors. So, we can combine the dollar sign notation and sum() function, to add up all the individual heights in the heights column of the class data frame. It looks like this: # First way to calculate the mean # (68 + 63 + 71 + 72) / 4 # Second way. Use dollar sign notation and bracket notation so that we don&#39;t have to type individual heights # (class$heights[1] + class$heights[2] + class$heights[3] + class$heights[4]) / 4 # Third way. Use dollar sign notation and sum function so that we don&#39;t have to type as much sum(class$heights) / 4 ## [1] 68.5 üëÜHere‚Äôs what we did above: We passed the numeric vector heights from the class data frame to the sum() function using dollar sign notation. The sum() function returned the total value of all the heights added together. We divided the total value of the heights by four ‚Äì the number of individual heights. 5.4.5 Nesting functions !! Before we move on, I want to point out something that is actually kind of a big deal. In the third method above, we didn‚Äôt manually add up all the individual heights - R did this calculation for us. Further, we didn‚Äôt store the sum of the individual heights somewhere and then divide that stored value by 4. Heck, we didn‚Äôt even see what the sum of the individual heights were. Instead, the returned value from the sum function (274) was used directly in the next calculation (/ 4) by R without us seeing the result. In other words, (68 + 63 + 71 + 72) / 4, 274 / 4, and sum(class$heights) / 4 are all exactly the same thing to R. However, the third method (sum(class$heights) / 4) is much more scalable (i.e., adding a lot more numbers doesn‚Äôt make this any harder to do) and much less error prone. Just be cleato r, the BIG DEAL is that we now know that the values returned by functions can be directly passed to other functions in exactly the same way as if we typed the values ourselves. This concept, functions passing values to other functions is known as nesting functions. It‚Äôs called nesting functions because we can put functions inside of other functions. ‚ÄúBut, Brad, there‚Äôs only one function in the command sum(class$heights) / 4 ‚Äì the sum() function.‚Äù Really? Is there? Remember when I said that operators are also functions in R? Well, the division operator is a function. And, like all functions it can be written with parentheses like this: # Writing the division operator as a function with parentheses `/`(8, 4) ## [1] 2 üëÜHere‚Äôs what we did above: We wrote the division operator in its more function-looking form. Because the division operator isn‚Äôt a letter, we had to wrap it in backticks (`). The backtick key is on the top left corner of your keyboard near the escape key (esc). The first agurment we passed to the division function was the dividend (The number we want to divide). The second argument we passed to the division function was the divisor (The number we want to divide by). So, the following two commands mean exactly the same thing to R: 8 / 4 `/`(8, 4) And if we use this second form of the division operator, we can clearly see that one function is nested inside another function. `/`(sum(class$heights), 4) ## [1] 68.5 üëÜHere‚Äôs what we did above: We calculated the mean height of the class. The first argument we passed to the division function was the returned value from the sum() function. The second argument we passed to the division function was the divisor (4). This is kind of mind-blowing stuff the first time you encounter it. ü§Ø I wouldn‚Äôt blame you if you are feeling overwhelmed or confused. The main points to take away from this section are: Everything we do in R, we will do with functions. Even operators are functions, and they can be written in a form that looks function-like; however, we will almost never actually write them in that way. Functions can be nested. This is huge because it allows us to directly pass returned values to other functions. Nesting functions in this way allows us to do very complex operations in a scalable way and without storing a bunch of unneeded values that are created in the intermediate steps of the operation. The downside of nesting functions is that it can make our code difficult to read - especially when we nest many functions. Fortunately, we will learn to use the pipe operator (%&gt;%) in the workflow basics part of this book. Once you get used to pipes, they will make nested functions much easier to read. Now, let‚Äôs get back to our analysis‚Ä¶ 5.4.6 The length function I think most of us would agree that the third method we learned for calculating the mean height is preferable to the first two methods for most situations. However, the third method still requires us to know how many individual heights are in the heights column (i.e., 4). Luckily, there is a function that tells us how many individual values are contained in a vector ‚Äì the length() function. Let‚Äôs take a look: # Create the heights vector heights &lt;- c(68, 63, 71, 72) # Return the number of individual values in heights length(heights) ## [1] 4 Remember, that data frame columns are also vectors. So, we can combine the dollar sign notation and length() function to automatically calculate the number of values in the heights column of the class data frame. It looks like this: # First way to calculate the mean # (68 + 63 + 71 + 72) / 4 # Second way. Use dollar sign notation and bracket notation so that we don&#39;t have to type individual heights # (class$heights[1] + class$heights[2] + class$heights[3] + class$heights[4]) / 4 # Third way. Use dollar sign notation and sum function so that we don&#39;t have to type as much # sum(class$heights) / 4 # Fourth way. Use dollar sign notation with the sum function and the length function sum(class$heights) / length(class$heights) ## [1] 68.5 üëÜHere‚Äôs what we did above: We passed the numeric vector heights from the class data frame to the sum() function using dollar sign notation. The sum() function returned the total value of all the heights added together. We passed the numeric vector heights from the class data frame to the length() function using dollar sign notation. The length() function returned the total number of values in the heights column. We divided the total value of the heights by the total number of values in the heights column. 5.4.7 The mean function The fourth method above is definitely the best method yet. However, this need to find the mean value of a numeric vector is so common that someone had the sense to create a function that takes care of all the above steps for us ‚Äì the mean() function. And as you probably saw coming, we can use the mean function like so: # First way to calculate the mean # (68 + 63 + 71 + 72) / 4 # Second way. Use dollar sign notation and bracket notation so that we don&#39;t have to type individual heights # (class$heights[1] + class$heights[2] + class$heights[3] + class$heights[4]) / 4 # Third way. Use dollar sign notation and sum function so that we don&#39;t have to type as much # sum(class$heights) / 4 # Fourth way. Use dollar sign notation with the sum function and the length function # sum(class$heights) / length(class$heights) # Fifth way. Use dollar sign notation with the mean function mean(class$heights) ## [1] 68.5 Congratulations again! You completed your first analysis using R! 5.5 Some common errors Before we move on, I want to briefly discuss a couple common errors that will frustrate many of you early in your R journey. You may have noticed that I went out of my way to differentiate between the heights vector and the heights column in the class data frame. As annoying as that may have been, I did it for a reason. The heights vector and the heights column in the class data frame are two separate things to the R interpreter, and you have to be very specific about which one you are referring to. To make this more concrete, let‚Äôs add a weight column to our class data frame. class$weight &lt;- c(160, 170, 180, 190) üëÜHere‚Äôs what we did above: We created a new column in our data frame ‚Äì weight ‚Äì using dollar sign notation. Now, let‚Äôs find the mean weight of the students in our class. mean(weight) ## Error in mean(weight): object &#39;weight&#39; not found Uh, oh! What happened? Why is R saying that weight doesn‚Äôt exist? We clearly created it above, right? Wrong. We didn‚Äôt create an object called weight in the code chunk above. We created a column called weight in the object called class in the code chunk above. Those are different things to R. If we want to get the mean of weight we have to tell R that weight is a column in class like so: mean(class$weight) ## [1] 175 A related issue can arise when you have an object and a column with the same name but different values. For example: # An object called scores scores &lt;- c(5, 9, 3) # A colummn in the class data frame called scores class$scores &lt;- c(95, 97, 93, 100) If you ask R for the mean of scores, R will give you an answer. mean(scores) ## [1] 5.666667 However, if you wanted the mean of the scores column in the class data frame, this won‚Äôt be the correct answer. Hopefully, you already know how to get the correct answer, which is: mean(class$scores) ## [1] 96.25 Again, the scores object and the scores column of the class object are different things to R. 5.6 Summary Wow! We covered a lot in this first part of the book on getting started with R and RStudio. Don‚Äôt feel bad if your head is swimming. It‚Äôs a lot to take-in. However, you should feel proud of the fact that you can already do some legitimately useful things with R. Namely, simulate and analyze data. In the next part of this book, we are going to discuss some tools and best practices that will make it easier and more efficient for you to write and share your R code. After that, we will move on to tackling more advanced programming and data analysis challenges. "],
["r-scripts.html", "6 R scripts 6.1 Creating R scripts", " 6 R scripts Up to this point, I‚Äôve only showed you how to submit your R code to R in the console. 6.1 Figure 6.1: Submitting R code in the console. Submitting code directly to the console in this way works well for quick little tasks and snippets of code. But, writing longer R programs this way has some drawbacks that are probably already obvious to you. Namely, your code isn‚Äôt saved anywhere. And, because it isn‚Äôt saved anywhere, you can‚Äôt modify it, use it again later, or share it with others. Technically, the statements above are not entirely true. When you submit code to the console, it is copied to RStudio‚Äôs History pane and from there you can save, modify, and share with others (see figure 6.2). But, this method is much less convenient, and provides you with far fewer whistles and bells than the other methods we‚Äôll discuss in this book. Figure 6.2: Console commands copied to the History pane. Those of you who have worked with other statistical programs before may be familiar with the idea of writing, modifying, saving, and sharing code scripts. SAS calls these code scripts ‚ÄúSAS programs‚Äù, Stata calls them ‚ÄúDO files‚Äù, and SPSS calls them ‚ÄúSPSS syntax files‚Äù. If you haven‚Äôt created code scripts before, don‚Äôt worry. There really isn‚Äôt much to it. In R, the most basic type of code script is simply called an R script. An R script is just a plane text file that contains R code and comments. R script files end with the file extension .R. Before I dive into giving you any more details about R scripts, I want to say that I‚Äôm actually going to discourage you from using them for most of what we do in this book. Instead, I‚Äôm going to encourage you to use R markdown files for the majority of your interactive coding, and for preparing your final products for end users. The next chapter is all about R markdown files. However, I‚Äôm starting with R scripts because: They are simpler than R markdown files, so they are a good place to start. Some of what I discuss below will also apply to R markdown files. R scripts are a better choice than R markdown files in some situations (e.g., writing R packages, creating Shiny apps). Some people just prefer using R scripts. With all that said, the screenshot below is of an example R script: Figure 6.3: Example R script. Click here to download the R script As you can see, I‚Äôve called out a couple key elements of the R script to discuss. 6.3 First, instead of just jumping into writing R code, lines 1-5 contain a header that I‚Äôve created with comments. Because I‚Äôve created it with comments, the R interpreter will ignore it. But, it will help other people you collaborate with (including future you) figure out what this script does. Therefore, I suggest that your header includes at least the following elements: A brief description of what the R script does. The author(s) who wrote the R script. Important dates. For example, the date it was originally created and the date it was last modified. You can usually get these dates from your computer‚Äôs operating system, but they aren‚Äôt always accurate. Second, you may notice that I also used comments to create something I‚Äôm calling decorations on lines 1, 5, and 17. Like all comments, they are ignored by the R interpreter. But, they help create visual separation between distinct sections of your R code, which makes your code easier for humans to read. I tend to use the equal sign (# ====) for separating major sections and the dash (# ----) for separating minor sections; although, ‚Äúmajor‚Äù and ‚Äúminor‚Äù are admittedly subjective. I haven‚Äôt explicitly highlighted it in the screenshot above, but it‚Äôs probably worth pointing out the use of line breaks (i.e., returns) in the code as well. This is much easier to read‚Ä¶ # Load packages library(dplyr) # Load data data(&quot;mtcars&quot;) # I&#39;m not sure what&#39;s in the mtcars data. I&#39;m printing it below to take a look mtcars ## Data analysis # ---------------------------------------------------------------------------- # Below, we calculate the average mpg across all cars in the mtcars data frame. mean(mtcars$mpg) # Here, we also plot mpg against displacement. plot(mtcars$mpg, mtcars$disp) than this‚Ä¶ # Load packages library(dplyr) # Load data data(&quot;mtcars&quot;) # I&#39;m not sure what&#39;s in the mtcars data. I&#39;m printing it below to take a look mtcars ## Data analysis # ---------------------------------------------------------------------------- # Below, we calculate the average mpg across all cars in the mtcars data frame. mean(mtcars$mpg) # Here, we also plot mpg against displacement. plot(mtcars$mpg, mtcars$disp) Third, it‚Äôs considered a best practice to keep each line of code to 80 characters (including spaces) or less. There‚Äôs a little box at the bottom left corner of your R script that will tell you what row your cursor is currently in and how many characters into that row your cursor is currently at (starting at 1, not 0). Figure 6.4: Cursor location. For example, 20:3 corresponds to having your cursor between the ‚Äúe‚Äù and the ‚Äúa‚Äù in mean(mtcars$mpg) in the example script above. 6.4 Fourth, it‚Äôs also considered a best practice to load any packages that your R code will use at the very top of your R script (lines 7 &amp; 8). 6.3 Doing so will make it much easier for others (including future you) to see what packages your R code needs to work properly right from the start. 6.1 Creating R scripts To create your own R scripts, click on the icon shown below 6.5 and you will get a dropdown box with a list of files you can create. 6.6 Figure 6.5: Click the new source file icon. Click the very first option ‚Äì R Script. Figure 6.6: New source file options. When you do, a new untitled R Script will appear in the source pane. Figure 6.7: A blank R script in the source pane. And that‚Äôs pretty much it. Everything else in figure 6.3 is just R code and comments about the R code. But, you can now easily save, modify, and share this code with others. In the next chapter, we are going to learn how to write R code in R markdown files, where we can add a ton of whistles and bells to this simple R script. "],
["r-markdown.html", "7 R markdown 7.1 What is R markdown? 7.2 Why use R markdown? 7.3 Create an R markdown file 7.4 YAML headers 7.5 R code chunks 7.6 Markdown", " 7 R markdown In the chapter on R Scripts, you learned how to create R scripts ‚Äì plane text files that contain R code and comments. These R scripts are kind of a big deal because they give us a simple and effective tool for saving, modifying, and sharing our R code. If it weren‚Äôt for the existence of R markdown files, we would probably do all of the coding in this book using R scripts. However, R markdown files do exist and they are AWESOME! So, I‚Äôm actually going to suggest that you use them instead of R scripts the majority of the time. It‚Äôs actually kind of difficult for me to describe what an R markdown file is if you‚Äôve never seen or heard of one before. Therefore, I‚Äôm going to start with an example and work backwards from there. Figure 7.1 below is an R markdown file. It includes the exact same R code and comments as the example we saw in the chapter on creating R scripts. 6.3 Figure 7.1: Example R markdown file. Click here to download the R markdown file Notice that the results are embedded directly in the R markdown file immediately below the R code (e.g., between lines 19 and 20)! Once rendered, this R markdown file creates the HTML file you see below in figure 7.2. HTML files are what websites are made out of, and I‚Äôll walk you through how to create them from R markdown files later in this chapter. Figure 7.2: Preview of HTML file created from an R markdown file. Click here to download the HTML notebook file. Notice how everything is nicely formatted and easy to read! When you create R markdown files on your computer, the rendered HTML file is saved in the same folder by default. 7.3 Figure 7.3: HTML notebook file and R markdown file on MacOS. In the figure above, the HTML notebook file is highlighted in blue and ends with the .nb.html file extension. The R markdown file is below the HTML notebook file and ends with the .Rmd file extension. Both of these files can be modified, saved, and shared with others. 7.1 What is R markdown? There is literally an entire book about R markdown (and it‚Äôs worth reading at some point). 2 Therefore, I‚Äôm only going to hit some of the highlights in this chapter. As a starting point, you can think of R markdown files as being a mix of R scripts, the R console, and a Microsoft Word or Google Doc document. I say this because: The R code that you would otherwise write in R scripts is written in R code chunks when you use R markdown files. In figure 7.1 there are R code chunks at lines 8 to 10, 12 to 14, 16 to 19, 25 to 27, and 31 to 33. Instead of having to flip back and forth between your source pane and your console (or viewer) pane in RStudio, the results from your R code are embedded directly in the R markdown file, right alongside the code that generated them. In figure 7.1 there are embedded results between lines 19 and 20, between lines 27 and 28, and between lines 33 and 34. When creating a document in Microsoft Word or Google Docs, you may format text headers to help organize your document, you may format your text to emphasize certain words, you may add tables to help organize concepts or data, you may add links to other resources, and you may add pictures or charts to help you clearly communicate ideas to yourself or others. Similarly, R markdown files allow you to surround your R code with formatted text, tables, links, pictures, and charts directly in your document. Even when I don‚Äôt share my R markdown files with anyone else, I find that the added functionality described above really helps me organize my data analysis more effectively, and helps me understand what I was doing if I come back to the analysis at some point in the future. But, R markdown really shines when I do want to share my analysis or results with others. To get an idea of what I‚Äôm talking about, please take a look at the R markdown gallery and view some of the amazing things you can do with R markdown. As you can see, these R markdown files mix R code with other kinds of text and images to create documents, websites, presentations, and more. 7.2 Why use R markdown? At this point, you may be thinking ‚ÄúOk, that R markdown gallery has some cool stuff, but this also looks complicated. Why shouldn‚Äôt I just use a basic R script for the little R program I‚Äôm writing?‚Äù If that‚Äôs what you‚Äôre thinking, you have a valid point. R markdown files are slightly more complicated than basic R scripts. However, after reading in the sections below, I think you will find that getting started with R markdown doesn‚Äôt have to be super complicated, and the benefits provided make the initial investment in learning R markdown worth your time. 7.3 Create an R markdown file RStudio makes it very easy to create your own R markdown file. The process is actually really similar to the process we used to create an R script. Start by clicking on the icon shown below. 7.4 Figure 7.4: Click the new source file icon. As before, you‚Äôll be presented with a dropdown box that lists a bunch of different file types that you can create. This time, we‚Äôll click R Notebook instead of R script. 7.5 Figure 7.5: New source file options. At this point you may have noticed that right below R Notebook in the dropdown menu is an option that says R Markdown... and you may be confused about why we aren‚Äôt choosing that option. Great observation! As I said at the beginning of this chapter, R markdown files have a ton of functionality. Usually, when things have a ton of functionality (e.g., phones, cars, computers) it comes at a cost. That cost is complexity. R markdown files are no exception. They are awesome, but it can take some time to learn how to take advantage of all they have to offer. R Notebooks ARE R markdown files, but they have some default settings that make it quick and easy for us to jump right into using them for doing some interactive R coding. üóí Side note: When I say ‚Äúinteractive R coding‚Äù I mean, type some R code, submit, see the result, type some more R code, submit it, see the result‚Ä¶ After you click the R Notebook option in the dropdown menu, a new untitled R notebook file will appear in the source pane. This R notebook will even include some example text and code meant to help get you started. We are typically going to erase all the example stuff and write our own text and code, but for now I will use it to highlight some key components of R markdown files. 7.6 Figure 7.6: A blank R script in the source pane. First, notice lines 1 through 4 in the example above. These lines make up something called the YAML header (pronounced yamel). You don‚Äôt need to know what YAML means, but you do need to know that this is one of the defining features of all R markdown files. Essentially, The YAML header turns plane text files into R markdown files. We‚Äôll talk more about the details of the YAML header soon. Second, notice lines 10 through 12. These lines make up something called an R code chunk. Code chunks in R markdown files always start with three backticks ( ` ) and a pair of curly braces ({}), and they always end with three more backticks. We know that this code chunk contains R code because of the ‚Äúr‚Äù inside of the curly braces. You can also create code chunks that will run other languages (e.g., python), but we won‚Äôt do that in this book. In this book, we will exclusively use the R language. You can think of each R code chunk as a mini R script. We‚Äôll talk more about the details of code chunks soon. Third, notice lines 6, 8, 14, and 18. These lines contain text instructions to help you use R notebooks, but in a real analysis you would use formatted text like this to add context around the analysis in the code chunks. For now, you can think of this as being very similar to the comments we wrote in our R scripts. However, this text is actually something called markdown, which allows us to do lots of cool things that the comments in our R scripts aren‚Äôt able to do. For example, line 6 has a link to a website embedded in it, and lines 8, 14, 16, and 18 all include text that is being formatted (the orange text wrapped in asterisks). In this case, the text is being italicized. And that is all you have to do to create an basic R notebook. Next, I‚Äôm going to give you a few more details about each of the key components of the R notebook that I briefly introduced above. 7.4 YAML headers As I said before, the YAML header is really what makes an R markdown file an R markdown file. The YAML header always begins and ends with dash-dash-dash (---) typed on its own line (1 &amp; 4 above). 7.6 The stuff written inside the YAML header generally falls into two categories: Stuff about the R markdown file itself. For example, the YAML header we saw above gives that R markdown file a title. The title is added to the file by adding the title keyword, followed by a colon (:), followed by a character string wrapped in quotes. Other examples include author and date. Stuff that tells R how to process the R markdown file. What do I mean by that? Well, remember the R markdown gallery you saw earlier? That gallery includes Word documents, PDF documents, websites, and more. But all of those different document types started as an R markdown file similar to the one in figure 7.6. R will create a PDF or a Word document or a website from the R markdown file based on the instructions you give it inside the YAML header. For example, the YAML header we saw above tells R to create an HTML Notebook from that R markdown file. This output type is selected by adding the output keyword, followed by a colon (:), followed by the html_notebook keyword. What does an HTML notebook look like? Well, if you hit the Preview button in RStudio: Figure 7.7: RStudio‚Äôs preview button. Only visible when an R notebook is open. R will ask you to save your R markdown file. After you save it, R will automatically create (or render) a new HTML notebook file and save it in the same location where your R markdown file is saved. Additionally, a little browser window will pop up and give you a preview of what the rendered HTML notebook looks like. 7.8 Figure 7.8: An HTML notebook created using an R markdown file. Notice how all the formatting that was applied when R rendered the HTML notebook file. For example, the title ‚Äì ‚ÄúR Notebook‚Äù ‚Äì is in big bold letters at the top of the screen, the words ‚ÄúR Markdown‚Äù in the first line of text are now a clickable link to another website, and the word ‚ÄúRun‚Äù in the second line of text is now italicized. I can imagine that this section may seem a little confusing to some of you right now. If so, don‚Äôt worry. You don‚Äôt really need to understand the YAML header right now. Remember, when you create a new R Notebook file in the manner I described above, the YAML header is already there. You will probably want to change the title, but that‚Äôs about it. 7.5 R code chunks As I said above, R code chunks always start out with three backticks ( ` ) and a pair of curly braces with an ‚Äúr‚Äù in them ({r}), and they always end with three more backticks. Typing that over and over can be tedious, so RStudio provides a keyboard shortcut for inserting R code chunks into your R markdown files. On Mac type option + command + i. On Windows type control + alt + i Inside your code chunk, you can type anything that you would otherwise type in the console or in an R script. You can then click the little green arrow in the top right corner of the code chunk to submit it to R and see the result. 7.9 Figure 7.9: The results of an R code chunk embedded in an R notebook. 7.6 Markdown Many of you have probably heard of HTML and CSS before. HTML stands for hypertext markup language and CSS stands for cascading style sheets. Together, HTML and CSS are used to create and style every website you‚Äôve ever seen. Remember that R notebooks created from our R markdown files are HTML files. They will open in any web browser and behave just like any other website. Therefore, you can manipulate and style them using HTML and CSS just like any other website. However, it takes a lot of time and effort to learn HTML and CSS. So, markdown was created as an easier-to-use alternative. Think of it as HTML and CSS lite. It can‚Äôt fully replace HTML and CSS, but it is much easier to learn, and you can use it to do many of the main things you would want to do with HTML and CSS. For example, in figures 7.6 and 7.8 you saw that wrapping your text with single asterisks (*) italicizes that text, and that using a combination of brackets and parentheses [Text](Link) can turn your text into a clickable link. There are a ton of other things you can do with markdown, and I recommend checking out RStudio‚Äôs R markdown cheat sheet if you‚Äôre interested in learning more. You can download it (any many other cheat sheets) here. The cheat sheet is a little bit busy and may feel overwhelming at first. So, I suggest starting with the section called ‚ÄúPandoc‚Äôs Markdown‚Äù on the second page of the cheat sheet. Just play around with some of the formatting options and get a feel for what they do. Having said that, it‚Äôs totally fine if you don‚Äôt care to try to tackle learning markdown syntax right now. You don‚Äôt really need markdown to follow along with the rest of the book. However, I still suggest using R Notebook files for writing, saving, modifying, and sharing your R code ‚Äì even if you don‚Äôt plan to format them with markdown syntax. References "],
["r-projects.html", "8 R projects", " 8 R projects In previous chapters of this book, you learned how to use R scripts and R markdown files to create, modify, save, and share your R code and results. In many real-world projects, you will end up creating multiple R scripts and/or R markdown files. You may even have other files (e.g., images or data) that you want to store alongside your R code files. Over time, keeping up with all of these files can become cumbersome. One tool for helping you organize and manage collections of files is to organize them with R project files. Because nothing we will do in this book really requires creating projects, I‚Äôm not going to discuss them further at this point. It would probably just end up confusing some of you unnecessarily. However, I wanted to mention that R project files exist in case you ever end up needing them someday for your real-world data analysis projects. I recommend that interested readers start with Grolemund and Wickham‚Äôs chapter on projects in R for Data Science. 3 References "],
["coding-best-practices.html", "9 Coding best practices 9.1 General principles 9.2 Code comments 9.3 Style guidelines", " 9 Coding best practices At this point in the book, we‚Äôve talked a little bit about what R is. We‚Äôve also talked about the RStudio IDE and took a quick tour around its four main panes. Finally, we wrote our first little R program, which simulated and analyzed some data about a hypothetical class. Writing and executing this R program officially made you an R programmer. üèÜ However, you should know that not all R code is equally ‚Äúgood‚Äù ‚Äì even when it‚Äôs equally valid. What do I mean that? Well, we already discussed the R interpreter and R syntax in the chapter on speaking R‚Äôs language. Any code that uses R syntax that the R interpreter can understand is valid R code. But, is the R interpreter the only one reading your R code? No way! In epidemiology, we collaborate with others all the time! That collaboration is going to be much more efficient and enjoyable when there is good communication ‚Äì including R code that is easy to read and understand. Further, you will often need to read and/or reuse code you wrote weeks, months, or years after you wrote it. You may be amazed at how quickly you forget what you did and/or why you did it that way. Therefore, in addition to writing valid R code, this chapter is about writing ‚Äúgood‚Äù R code ‚Äì code that easily and efficiently communicates ideas to humans. Of course, ‚Äúgood code‚Äù is inevitably somewhat subjective. Reasonable people can have a difference of opinion about the best way to write code that is easy to read and understand. Additionally, reasonable people can have a difference of opinion about when code is ‚Äúgood enough.‚Äù For these reasons, I‚Äôm going to offer several ‚Äúsuggestions‚Äù about writing good R code below, but only two general principles, which I believe most R programmers would agree with. 9.1 General principles Comment your code. Whether you intend to share your code with other people or not, make sure to write lots of comments about what you are trying to accomplish in each section of your code and why. Use a style consistently. I‚Äôm going to suggest several guidelines for styling your R code below, but you may find that you prefer to style your R code in a different way. Whether you adopt my suggested style or not, please find or create a style that works for you and your collaborators and use it consistently. 9.2 Code comments There isn‚Äôt a lot of specific advice that I can give here because comments are so idiosyncratic to the task at hand. So, I think the best I can do at this point is to offer a few examples for you to think about. 9.2.1 Defining key variables As we will discuss below, variables should have names that are concise, yet informative. However, the data you receive in the real world will not always include informative variable names. Even when someone has given the variables informative names, there may still be contextual information about the variables that is important to understand for data management and analysis. Some data sets will come with something called a codebook or data dictionary. These are text files that contain information about the data set that are intended to provide you with some of that more detailed information. For example, the survey questions that were used to capture the values in each variable or what category each value in a categorical variable represents. However, real data sets don‚Äôt always come with a data dictionary, and even when they do, it can be convenient to have some of that contextual information close at hand, right next to your code. Therefore, I will sometimes comment my code with information about variables that are important for the analysis at hand. Here is an example from an administrative data set I was using for an analysis: * **Case number definition** - Case / investigation number. * **Intake stage definition** - An ID number assigned to the Intake. Each Intake (Report) has its own number. A case may have more than one intake. For example, case # 12345 has two intakes associated with it, 9 days apart, each with their own ID number. Each of the two intakes associated with this case have multiple allegations. * **Intake start definition** - An intake is the submission or receipt of a report - a phone call or web-based. The Intake Start Date refers to the date the staff member opens a new record to begin recording the report. 9.2.2 What this code is trying to accomplish Sometimes, it is obvious what a section of code literally does. but not so obvious why you‚Äôre doing it. I often try to write some comments around my code about what it‚Äôs trying to ultimately accomplish and why. For example: ## Standardize character strings # Because we will merge this data with other data sets in the future based on # character strings (e.g., name), we need to go ahead and standardize their # formats here. This will prevent mismatches during the merges. Specifically, # we: # 1. Transform all characters to lower case # 2. Remove any special characters (e.g., hyphens, periods) # 3. Remove trailing spaces (e.g., &quot;John Smith &quot;) # 4. Remove double spaces (e.g., &quot;John Smith&quot;) vars &lt;- quos(full_name, first_name, middle_name, last_name, county, address, city) client_data &lt;- client_data %&gt;% mutate_at(vars(!!! vars), tolower) %&gt;% mutate_at(vars(!!! vars), stringr::str_replace_all, &quot;[^a-zA-Z\\\\d\\\\s]&quot;, &quot; &quot;) %&gt;% mutate_at(vars(!!! vars), stringr::str_replace, &quot;[[:blank:]]$&quot;, &quot;&quot;) %&gt;% mutate_at(vars(!!! vars), stringr::str_replace_all, &quot;[[:blank:]]{2,}&quot;, &quot; &quot;) rm(vars) 9.2.3 Why I chose this particular strategy In addition to writing comments about why I did something, I sometimes write comments about why I did it instead of something else. Doing this can save you from having to relearn lessons you‚Äôve already learned through trial and error but forgot. For example: ### Create exact match dummy variables * We reshape the data from long to wide to create these variables because it significantly decreases computation time compared to doing this as a group_by operation on the long data. 9.3 Style guidelines UsInG c_o_n_s_i_s_t_e_n_t STYLE i.s. import-ant! Good coding style is like using correct punctuation. You can manage without it, but it sure makes things easier to read. As with styles of punctuation, there are many possible variations‚Ä¶ Good style is important because while your code only has one author, it‚Äôll usually have multiple readers. This is especially true when you‚Äôre writing code with others. In that case, it‚Äôs a good idea to agree on a common style up-front. Since no style is strictly better than another, working with others may mean that you‚Äôll need to sacrifice some preferred aspects of your style. 4 Below, I outline the style that I and my collaborators typically use when writing R code for a research project. It generally follows the Tidyverse style guide, which I strongly suggest you read. Outside of my class, you don‚Äôt have to use my style, but you really should find or create a style that works for you and your collaborators and use it consistently. 9.3.1 Object (variable) names In addition to the object naming guidance given in the Tidyverse style guide, I suggest the following object naming conventions. 9.3.2 Use names that are informative Using names that are informative and easy to remember will make life easier for everyone who uses your data ‚Äì including you! # Uninformative names - Don&#39;t do this x1 var1 # Informative names employed married education 9.3.2.1 Use names that are concise You want names to be informative, but you don‚Äôt want them to be overly verbose. Really long names create more work for you and more opportunities for typos. In fact, I recommend using a single word when you can. # Write out entire name of the study the data comes from - Don&#39;t do this womens_health_initiative # Write out an acronym for the study the data comes from - assuming everyone # will be familiar with this acronym - Do this whi 9.3.2.2 Use all lowercase letters Remember, R is case-sensitive, which means that myStudyData and mystudydata are different things to R. Capitalizing letters in your file name just creates additional details to remember and potentially mess up. Just keep it simple and stick with lowercase letters. # All upper case - so aggressive - Don&#39;t use MYSTUDYDATA # Camel case - Don&#39;t use myStudyData # All lowercase - Use my_study_data 9.3.2.3 Separate multiple words with underscores. Sometimes you really just need to use multiple words to name your object. In those cases, I suggested separating words with an underscore. # Multiple words running together - Hard to read - Don&#39;t use mycancerdata # Camel case - easier to read, but more to remember and mess up - Don&#39;t use myCancerData # Separate with periods - easier to read, but doesn&#39;t translate well to many # other languages. For example, SAS won&#39;t accept variable names with # periods - Don&#39;t use my.cancer.data # Separate with underscores - Use my_cancer_data 9.3.2.4 Prefix the names of similar variables When you have multiple related variables, it‚Äôs good practice to start their variable names with the same word. It makes these related variables easier to find and work with in the future if we need to do something with all of them at once. We can sort our variable names alphabetically to easily find find them. Additionally, we can use variable selectors like starts_with(\"name\") to perform some operation on all of them at once. # Don&#39;t use first_name last_name middle_name # Use name_first name_last name_middle # Don&#39;t use street city state # Use address_street address_city address_state 9.3.3 File Names All the variable naming suggestons above also apply to file names. However, I make a few additional suggestions specific to file names below. 9.3.3.1 Managing multiple files in projects When you are doing data management and analysis for real-world projects you will typically need to break the code up into multiple files. If you don‚Äôt, the code often becomes really difficult to read and manage. Having said that, finding the code you are looking for when there are 10, 20, or more separate files isn‚Äôt much fun either. Therefore, I suggest the following (or similar) file naming conventions be used in your projects. Separate data cleaning and data analysis into separate files (typically, .R or .Rmd). Data cleaning files should be prefixed with the word ‚Äúdata‚Äù and named as follows data_[order number]_[purpose] # Examples data_01_import.Rmd data_02_clean.Rmd data_03_process_for_regression.Rmd Analysis files that do not directly create a table or figure should be prefixed with the word ‚Äúanalysis‚Äù and named as follows analysis_[order number]_[brief summary of content] # Examples analysis_01_exploratory.Rmd analysis_02_regression.Rmd Analysis files that DO directly create a table or figure should be prefixed with the word ‚Äútable‚Äù or ‚Äúfig‚Äù respectively and named as follows table_[brief summary of content] or fig_[brief summary of content] # Examples table_network_characteristics.Rmd fig_reporting_patterns.Rmd üóí Side note: I sometimes do data manipulation (create variables, subset data, reshape data) in an analysis file if that analysis (or table or chart) is the only analysis that uses the modified data. Otherwise, I do the modifications in a separate data cleaning file. Images Should typically be exported as png (especially when they are intended for use HTML files). Should typically be saved in a separate ‚Äúimg‚Äù folder under the project home directory. Should be given a descriptive name. Example: histogram_heights.png, NOT fig_02.png. -I have found that the following image sizes typically work pretty well for my projects. 1920 x 1080 for HTML 770 x 360 for Word Word and PDF output files I typically save them in a separate ‚Äúdocs‚Äù folder under the project home directory Whenever possible, I try to set the Word or PDF file name to match the name of the R file that it was created in. Example: first_quarter_report.Rmd creates docs/first_quarter_report.pdf Exported data files (i.e., RDS, RData, CSV, Excel, etc.) I typically save them in a separate ‚Äúdata‚Äù folder under the project home directory. Whenever possible, I try to set the Word or PDF file name to match the name of the R file that it was created in. Example: data_03_texas_only.Rmd creates data/data_03_texas_only.csv References "],
["using-pipes.html", "10 Using pipes", " 10 Using pipes "],
["overview.html", "11 Overview 11.1 Measurement 11.2 Descriptive analysis", " 11 Overview 11.1 Measurement Measurement: We typically evaluate and quantify our intuition about health and disease with numbers. This could be relative to anecdotes. Surely, the one person who happened to survive cancer through a diet exclusively of honey could have had an article written about them. That doesn‚Äôt mean honey cured that person‚Äôs cancer, and even if it did, it doesn‚Äôt mean that it would be likely to cure cancer in you. 11.2 Descriptive analysis Bring over PowerPoint and all the Rmd files from last year‚Äôs course. "],
["appendix-a-glossary.html", "Appendix A: Glossary", " Appendix A: Glossary Console. Coming soon. Data frame. For our purposes, data frames are just R‚Äôs term for data set or data table. Data frames are made up of columns (variables) and rows (observations). In R, all columns of a data frame must have the same length. Functions. Coming soon. Arguments: Arguments always go inside the parentheses of a function and give the function the information it needs to give us the result we want. Pass: In programming lingo, you pass a value to a function argument. For example, in the funtion call seq(from = 2, to = 100, by = 2) we could say that we passed a value of 2 to the from argument, we passed a value of 100 to the to argument, and we passed a value of 2 to the by argument. Returns: Instead of saying, ‚Äúthe seq() function gives us a sequence of numbers‚Ä¶‚Äù we could say, ‚Äúthe seq() function returns us a sequence of numbers‚Ä¶‚Äù In programming lingo, functions return one or more results. Global environment. Coming soon. Objects. Coming soon. R. R is an integrated suite of software facilities for data manipulation, calculation and graphical display. R is very much a vehicle for newly developing methods of interactive data analysis. It has developed rapidly and has been extended by a large collection of packages. However, most programs written in R are essentially ephemeral, written for a single piece of data analysis. 5 R markdown documents. R markdown documents are text files that can be used to clean and analyze your data interactively as well as share your final results in many different formats (e.g., Microsoft Word, PDF, and even websites). R markdown documents weave together R code, narrative text, and multimedia content together into a polished final product. 6 RStudio. RStudio is an integrated development environment (IDE) for R. It includes a console, syntax-highlighting editor that supports direct code execution, as well as tools for plotting, history, debugging and workspace management. RStudio is available in open source and commercial editions and runs on the desktop (Windows, Mac, and Linux) or in a browser connected to RStudio Server or RStudio Server Pro (Debian/Ubuntu, Red Hat/CentOS, and SUSE Linux). 7 "]
]
